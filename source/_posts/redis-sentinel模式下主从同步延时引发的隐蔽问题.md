---
title: redis sentinel模式下主从同步延时引发的隐蔽问题
date: 2019-07-28 22:37:34
tags:
- redis
- 缓存回写
- 主从同步
---

线上低概率出现搜索商品的时候返回空结果，但再一次搜索就可以返回结果。隐约可以感觉到时缓存的问题，因为第一次搜索的时候没有命中缓存，因此会从穿透到es查找数据，然后之后搜索同样的商品就直接从缓存中取数据，因此之后的搜索都会有返回结果。还有一点就是，搜索接口如果返回商品较少时几乎没有出现过返回结果为空的现象。

通过之前的分析去看业务代码，发现业务代码在处理未命中缓存的逻辑时，并没有把从es中取到的数据返回，而是直接将结果设置到缓存中；如此，就可以统一缓存命中和未命中时的处理代码。

之前对redis客户端代码进行封装的时候，特别处理exists方法的封装。在sentinel模式或者主从模式下，redisson客户端会将判断key是否exists函数认定为读命令，所有的读命令都会路由到slave节点执行。而主从同步过程中，可能出现master节点key存在，但是slave节点key却不存在的情况。为此，使用了redis的SHA函数，因为redisson客户端只有使用脚本才能指定由master节点执行命令。

同样，这段处理搜索未命中的代码也有类似的问题。对于搜索接口的逻辑未命中缓存时如下：
1. 判断key是否在缓存中
2. 没有在缓存中，从es中取数据
3. 设置缓存的key值
4. 从缓存取该key值

看似没有问题，但是在第3步执行完之后，如果第4步没有等master节点将该key的值同步到slave节点就已经执行，那第4步就取不到该key的值，于是就出现了搜索返回结果为空的问题。找到了问题产生的原因，处理问题也就比较好办，直接将第4步改成将es中获取到的数据直接返回即可。

使用redis实现分布式锁也存在类似的问题，即当master锁设置完成之后未来得及同步给slave，此时master节点宕机了，锁也就跟着一起丢失。redis作者又实现了RedLock来解决该问题，具体就不详细展开了。