---
title: 一致性hash和分布式缓存的一些思考
date: 2020-04-26 22:39:02
tags:
- 一致性hash
- 分布式缓存
---

Redis是当下流行的分布式缓存系统，其丰富灵活的数据机构和高效的性能深受开发者喜爱。有些应用场景，我们可能大量的缓存数据，比如所有用户购物商品的缓存。这样的缓存需要占用大量内存，如果使用Redis来实现，要不使用Codis这样的代理层来将数据存储到不同的Redis集群，要不就直接使用Redis集群模式来手动管理Key分片。但是Redis集群配置麻烦，而Codis的引入会有性能的损失（Codis作为第三方集群实现方案，很多Redis新特性短时间内无法支持也是个问题）。而如果想在应用服务本地使用缓存来存储用户行为等这样的大量的数据，会经常发生缓存被驱逐的情况，缓存的命中率和性能效果都不会很理想。有什么方案可以将大批量的数据缓存在应用本地的同时能提高本地缓存的命令率，并且可以做到缓存空间弹性水平（非垂直）伸缩？答案就是使用__一致性hash路由__算法。比如上述用户购物车商品的缓存的场景，都是通过用户维度查询商品列表，我们就可以根据用户id计算hash值之后路由后向服务提供方发起请求。

#### 缓存命令率的提高

同一个用户的请求会请求道相同的机器，同一个用户多次请求同一个接口的情况下，命中率自然比通过随机或者轮询的方式命中率高。并且，如果同一个用户多次通过随机或者轮询的路由方式请求同一个接口，如果请求的机器未命中缓存，该机器就需要重建最近一次请求返回数据的缓存，这就会占用该机器的缓存空间。这样，该机器就更容易触发缓存回收操作，影响其他请求的缓存命令率。

#### 缓存空间的水平拓展

随着单位时间内用户请求量的提升，应用就需要更大的缓存空间以满足性能需求。使用一致性hash路由的方式，我们可以很方便的通过增加应用服务机器的方式水平扩展应用服务缓存空间，让部分新用户和部分旧用户的请求落到新增的机器上。这一点，依赖于一致性hash算法的虚拟节点实现的负载均衡算法来满足。

#### 缓存的准实时更新

一般情况下，数据库数据的变更，我们一般不主动通知应用服务去更新缓存，而是通过应用服务的缓存过期机制（被动）来保持缓存和数据库数据的同步。通过过期机制同步数据的主要缺点在于，数据库数据的变更和缓存过期存在一定的时间窗口。这个时间窗口内，用户请求接口得到的数据是不准确的。如果想在这个时间窗口内同步数据库的数据变更到本地缓存，需要使用广播的方式通知到所有的应用服务（这对网络带宽、性能和代码实现都是很不友好的）。而通过一致性hash路由算法，我们只需要通知到一台应用服务即可，如此，我们只需在数据库变更之后（MySQL的话推荐使用binlog监听方式来感知数据变更），使用一致性hash路由调用应用服务的缓存更新接口即可。

完

